// Autogenerated from Pigeon (v13.1.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.example.qrcode

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
import android.app.Activity
import android.content.Intent
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import io.flutter.embedding.engine.plugins.activity.ActivityAware
import io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding
import io.flutter.embedding.engine.plugins.FlutterPlugin
import io.flutter.plugin.common.MethodChannel
import com.journeyapps.barcodescanner.ScanOptions
import com.journeyapps.barcodescanner.CaptureActivity
import android.widget.Toast
import androidx.activity.ComponentActivity
import com.journeyapps.barcodescanner.ScanContract
import com.journeyapps.barcodescanner.ScanIntentResult
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException
import kotlin.coroutines.suspendCoroutine
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import android.view.ViewGroup
import android.widget.FrameLayout

import android.Manifest
import android.content.pm.PackageManager
import androidx.camera.core.CameraSelector
import androidx.camera.core.ImageAnalysis
import androidx.camera.core.ImageProxy
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.content.ContextCompat
import com.google.zxing.*
import com.google.zxing.common.HybridBinarizer
import java.util.concurrent.Executor
import java.util.concurrent.atomic.AtomicBoolean

class QRCodeScannerApiImpl(private val activity: Activity) : QRCodeScannerApi {

  override suspend fun scanQRCode(): ScanQRCodeResult {
    return suspendCoroutine { continuation ->
      
      /*
      val options = ScanOptions()
      options.setDesiredBarcodeFormats(ScanOptions.QR_CODE)
      options.setPrompt("Escanea un código QR")
      options.setBeepEnabled(true)
      options.setOrientationLocked(false)
      options.setCameraId(0)
      */

      /*
      val intent = Intent(activity, CaptureActivity::class.java)
      intent.putExtra("SCAN_OPTIONS", options)
      resultLauncher.launch(intent)
      */

      /*
      val scannerLauncher = (activity as ComponentActivity).registerForActivityResult<ScanOptions, ScanIntentResult>(
        ScanContract()
      ) { result ->

        if (result.contents == null) {
          //Toast.makeText(this, "Cancelled", Toast.LENGTH_SHORT).show()
          continuation.resume(ScanQRCodeResult( "Cancelled", null))
        } else {
          continuation.resume(ScanQRCodeResult( null, result.contents))
        }
      }
      scannerLauncher.launch(options)
      */
        val executor: Executor = ContextCompat.getMainExecutor(activity)

      if (ContextCompat.checkSelfPermission(activity, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
          //return QRScanResult().apply { error = "Camera permission not granted" }
          continuation.resume(ScanQRCodeResult( "Permisos denegados", null))
      }

      //val result = QRScanResult()
      val cameraProviderFuture = ProcessCameraProvider.getInstance(activity)

      cameraProviderFuture.addListener({
          val cameraProvider = cameraProviderFuture.get()
          val preview = Preview.Builder().build()
          val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA

          val imageAnalysis = ImageAnalysis.Builder()
              .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
              .build()


          val layout = FrameLayout(activity).apply {
              layoutParams = FrameLayout.LayoutParams(
                  FrameLayout.LayoutParams.MATCH_PARENT,
                  FrameLayout.LayoutParams.MATCH_PARENT
              )
          }

          val previewView = PreviewView(activity).apply {
              layoutParams = FrameLayout.LayoutParams(
                  ViewGroup.LayoutParams.MATCH_PARENT,
                  ViewGroup.LayoutParams.MATCH_PARENT
              )
              scaleType = PreviewView.ScaleType.FILL_CENTER
          }

          imageAnalysis.setAnalyzer(executor) { imageProxy ->
              //if (isScanning.compareAndSet(false, true)) {
                  try {
                      val qrCode = processImage(imageProxy)
                      if (qrCode != null) {
//                          result.code = qrCode
                          continuation.resume(ScanQRCodeResult( null, qrCode))
                          layout.removeView(previewView)
                          cameraProvider.unbindAll() // Detener después de encontrar un QR
                      }
                  } catch (e: Exception) {
                      continuation.resume(ScanQRCodeResult( "Error scanning QR: ${e.message}", null))
                  } finally {
                      imageProxy.close()
                  }
          }


          layout.addView(previewView)

          preview.setSurfaceProvider(previewView.surfaceProvider)
          //(activity as ComponentActivity).setContentView(layout)

          (activity as ComponentActivity).addContentView(layout, FrameLayout.LayoutParams(
              FrameLayout.LayoutParams.MATCH_PARENT,
              FrameLayout.LayoutParams.MATCH_PARENT
          ))
          cameraProvider.unbindAll()
          activity.runOnUiThread {
              cameraProvider.bindToLifecycle((activity as ComponentActivity), cameraSelector, preview, imageAnalysis)
          }
      }, ContextCompat.getMainExecutor(activity))
      
    }
  }

    private fun processImage(imageProxy: ImageProxy): String? {
        val buffer: ByteBuffer = imageProxy.planes[0].buffer
        val data = ByteArray(buffer.remaining())
        buffer.get(data)

        val source = PlanarYUVLuminanceSource(
            data,
            imageProxy.width,
            imageProxy.height,
            0,
            0,
            imageProxy.width,
            imageProxy.height,
            false
        )

        val binaryBitmap = BinaryBitmap(HybridBinarizer(source))
        val reader = MultiFormatReader()

        return try {
            val result = reader.decode(binaryBitmap)
            result.text
        } catch (e: NotFoundException) {
            null // No se encontró QR
        } catch (e: Exception) {
            throw e // Otros errores
        }
    }

}

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  if (exception is FlutterError) {
    return listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    return listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/** Generated class from Pigeon that represents data sent in messages. */
data class ScanQRCodeResult (
  val errorMessage: String? = null,
  val code: String? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ScanQRCodeResult {
      val errorMessage = list[0] as String?
      val code = list[1] as String?
      return ScanQRCodeResult(errorMessage, code)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      errorMessage,
      code,
    )
  }
}
@Suppress("UNCHECKED_CAST")
private object QRCodeScannerApiCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ScanQRCodeResult.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is ScanQRCodeResult -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface QRCodeScannerApi {
  suspend fun scanQRCode(): ScanQRCodeResult

  companion object {
    /** The codec used by QRCodeScannerApi. */
    val codec: MessageCodec<Any?> by lazy {
      QRCodeScannerApiCodec
    }
    /** Sets up an instance of `QRCodeScannerApi` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: QRCodeScannerApi?) {
      run {
        println("*** LOG: Setup de QR Scanner Plugin iniciado")
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.qr_scanner_plugin.QRCodeScannerApi.scanQRCode", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            CoroutineScope(Dispatchers.Main).launch {
              var wrapped: List<Any?>
              try {
                wrapped = listOf<Any?>(api.scanQRCode())
              } catch (exception: Throwable) {
                wrapped = wrapError(exception)
              }
              reply.reply(wrapped)
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
